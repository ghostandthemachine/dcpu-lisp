{"name":"LCPU","body":"LCPU is a simple Lisp-like language that compiles to optimized DCPU-16 assembly code. It is a very restricted subset of Lisp. There is no GC, and thus no data structures or run-time closures.\r\n\r\nThis is intended for usage in Mojang's next game, [0x10c](<http://0x10c.com/>).\r\n\r\n* Example program: https://github.com/jlongster/dcpu-lisp/blob/master/examples/print-number.l\r\n* Generated assembly: https://github.com/jlongster/dcpu-lisp/blob/master/examples/print-number.asm\r\n* Watch it run here: http://0x10co.de/imq63\r\n\r\n# High-level Assembly\r\n\r\nThink of it as a light wrapper around the assembly code, providing named variables, lexically-bound closures, and a little bit of helpful magic here and there.\r\n\r\nCreate a function like so:\r\n\r\n    (define (foo x)\r\n      (+ x 1))\r\n\r\nVariable references are statically referenced and compiled out straight to registers. In one function, you are not allowed more variable definitions than there are registers (7, and the 8th is used for the return value).\r\n\r\nNested functions are allowed:\r\n\r\n    (define (foo x)\r\n      (define (bar y)\r\n        (+ x y))\r\n      (bar 10))\r\n\r\nRun-time closures are not available because of the lack of GC, so the closed function cannot out-live its parent (you can't return `bar`).\r\n\r\nOnly 2 kinds of values exist: functions and 16-bit numbers.\r\n\r\nThere is a lot more we could do to enrich the language but still keep provable semantics statically.\r\n\r\nIt is written in Outlet, a Lisp that compiled to Javascript, so the compiler can run in browser. See https://github.com/jlongster/outlet. The js is packaged with the project so you can run it with Node.\r\n\r\n# Features\r\n\r\n* Named functions and variables\r\n* Nested functions\r\n* Inlinable arithmetic expressions\r\n* Inline assembly\r\n* Macros\r\n* Small standard library\r\n* Probably other stuff I've forgotten about\r\n\r\n# Does Not Have\r\n\r\n* Garbage Collector\r\n* Heap\r\n* Run-time closures\r\n* Data types/structures\r\n* Type inference\r\n\r\n# Usage\r\n\r\nUse the `lcpu` script in the `bin` directory:\r\n\r\n`./bin/lcpu program.l`\r\n\r\nIt will print the generated assembly to standard output.\r\n\r\n    lcpu [-p] [-c1] [-c2] [-c3] [-l] [-e] <program/expression>\r\n\r\n    * -p: print the expanded program\r\n    * -c1: print the code after the first compilation phase\r\n    * -c2: print the code after the second compilation phase\r\n    * -c3: print the code after the third compilation phase\r\n    * -l: print the code after the linearization phase\r\n    * -e: run an expression instead of a file\r\n\r\nIf you get an error, you may have to run this: `touch compiler.ol && make`\r\n\r\n# Examples\r\n\r\nYou can see all the examples in the [examples](https://github.com/jlongster/dcpu-lisp/tree/master/examples>)\r\ndirectory.\r\n\r\n## Number Printing\r\n\r\nThis code defines `print-number` which prints a number to the console:\r\n\r\n    (define (print color bg-color x y text)\r\n      (MUL y 32)\r\n      (ADD y x)\r\n      (ADD y 0x8000)\r\n      (SHL color 12)\r\n      (SHL bg-color 8)\r\n      (BOR text color)\r\n      (BOR text bg-color)\r\n      (SET [y] text))\r\n\r\n    (define (%print-number n i)\r\n      (define (p n)\r\n        (print 0xf 0 (- 31 i) 0 (+ 0x30 n)))\r\n\r\n      (if (< n 10)\r\n          (p n)\r\n          (begin\r\n            (p (% n 10))\r\n            (%print-number (/ n 10) (+ i 1)))))\r\n\r\n    (define (print-number n)\r\n      (%print-number n 0))\r\n\r\n    (print-number 12345)\r\n\r\n## Fib\r\n\r\nHere is the fib program and the resulting assembly code (without the runtime, which just provides a few helpful functions). You can get the full assembly code in examples/fib.asm.\r\n\r\n    (define (fib a)\r\n      (if (<= a 1)\r\n          1\r\n          (+ (fib (- a 1))\r\n             (fib (- a 2)))))\r\n    \r\n    ;; result will be in register J\r\n    (fib 8)\r\n\r\nGenerated assembly:\r\n\r\n    JSR global_dash_entry\r\n    SET PC, __exit\r\n\r\n    :global_dash_entry\r\n    SET PUSH, return_dash_o1957346\r\n    SET PUSH, 0x8\r\n    SET PC, global_dash_entry_dash_fib\r\n    :return_dash_o1957346\r\n    SET PC, POP\r\n    :global_dash_entry_dash_fib\r\n    SET A, POP\r\n    SET PUSH, A\r\n    SET PUSH, return_dash_o3554470\r\n    SET PUSH, A\r\n    SET PUSH, 0x1\r\n    SET PC, global_dash__lt__eq_\r\n    :return_dash_o3554470\r\n    SET A, POP\r\n    IFE J, 0x0\r\n    SET PC, alt_dash_o5960250\r\n    SET J, 0x1\r\n    SET PC, exit_dash_o9848488\r\n    :alt_dash_o5960250\r\n    SET PUSH, A\r\n    SET PUSH, return_dash_o7693500\r\n    SET PUSH, A\r\n    SET PUSH, return_dash_o6022101\r\n    SET J, A\r\n    SUB J, 0x1\r\n    SET PUSH, J\r\n    SET PC, global_dash_entry_dash_fib\r\n    :return_dash_o6022101\r\n    SET A, POP\r\n    SET PUSH, J\r\n    SET PUSH, A\r\n    SET PUSH, return_dash_o8008109\r\n    SET J, A\r\n    SUB J, 0x2\r\n    SET PUSH, J\r\n    SET PC, global_dash_entry_dash_fib\r\n    :return_dash_o8008109\r\n    SET A, POP\r\n    SET PUSH, J\r\n    SET PC, _plus_\r\n    :return_dash_o7693500\r\n    SET A, POP\r\n    :exit_dash_o9848488\r\n    SET PC, POP\r\n    :__exit\r\n    SET PC, __exit\r\n\r\nYou can also view the tests in the `tests` directory to see how certain expressions are compiled.\r\n\r\n# Inline Assembly\r\n\r\nIf you want, you can code straight DCPU-16 assembly into your program. For example, here is a function that prints values to the console:\r\n\r\n    (define (print color bg-color x y text)\r\n      (MUL y 32)\r\n      (ADD y x)\r\n      (ADD y 0x8000)\r\n      (SHL color 12)\r\n      (SHL bg-color 8)\r\n      (BOR text color)\r\n      (BOR text bg-color)\r\n      (SET [y] text))\r\n\r\nDereferencing is supported with the normal bracket syntax (i.e. `[y]`).\r\n\r\n# Macros\r\n\r\n`define-macro` is provided for defining macros:\r\n\r\n    (define-macro (foo t x y)\r\n      `(begin\r\n         (define ,t (+ ,x ,y))\r\n         (MUL ,t 50)))\r\n\r\n    (foo z 1 2)\r\n\r\nis converted into:\r\n\r\n    (begin\r\n      (define z (+ 1 2))\r\n      (MUL z 50))\r\n\r\nThis is a powerful construct to make sure you can generate optimized assembly code.\r\n\r\n# Iteration\r\n\r\nThe `do` construct provides iteration. There are two versions of `do`:\r\n\r\n    ;; Runs the expression with x starting at 0 and incrementing by 1\r\n    ;; until it hits 32\r\n    (do (x 0 32)\r\n        (print (* x 20)))\r\n\r\n    ;; Or you can provide your own start, stepping and stopping\r\n    ;; expressions.\r\n    ;; Here x starts as 0, is incremented by 5 and continues looping while\r\n    ;; x is less than 100\r\n    (do (x 0 (+ x 5) (< x 100))\r\n        (print x)\r\n        (print (/ x 2)))\r\n\r\n\r\n# Future work\r\n\r\n* More optimizations\r\n* A stepping-debugger\r\n\r\nThere are many more static optimizations we could do. I'm sure there are bugs in this too, as it is rather untested. Please report issues on github if you find any, or contact me at longster@gmail.com.\r\n\r\nFollow me on twitter: [@jlongster](http://twitter.com/jlongster)\r\n","tagline":"A Lisp-like language that compiles to DCPU-16 assembly code","google":"UA-31070259-1","note":"Don't delete this file! It's used internally to help with page regeneration."}